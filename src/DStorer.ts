import Interaction from './Interaction'
import Document from './Document'
import {
  IDocument,
  IStore,
  IStorer,
  IStoreCollection,
  IStoreQuery,
  IStoreResult,
  MaybeDate,
  MaybeString,
  Ref,
  SYSTEM_REF,
} from './types'

/**
 * This class stores Documents into a configurable backend
 */
export default class DStorer implements IStore{
  /**
   * Environement which is being used
   */
  env: string

  /**
   * Namespace which is being used
   */
  namespace: string

  /**
   * Current Ref to attribute interactions to
   */
  ref: Ref

  /**
   * Backend for storage
   */
  _backend: IStorer

  /**
   * Instance of store generated by the backend
   */
  _store: IStore

  /**
   * Is test mode?
   */
  isTest: boolean

  /**
   * Record all docs if test mode
   */

  docs: IDocument[] = []

  /**
   * Create a DStorer
   * @param backend Supply an IStorer Object such as the FireBaseStorer
   * @param ref use to set the interaction reference for creates, updates, and
   * deletes
   */
  constructor(
    backend: IStorer,
    env: string = 'dev',
    namespace: string = 'dev-org',
    ref: Ref = SYSTEM_REF,
    opts: any = {}
  ) {
    this._backend = backend
    this.ref = ref
    this.env = env
    this.namespace = namespace

    this.isTest = opts.test

    this._store = backend.getStore(this.env, this.namespace)
  }

  /**
   * Clean up docs if in test mode
   */
  async cleanUp(): Promise<any> {
    if (this.docs.length === 0) {
      return
    }

    for (const d of this.docs) {
      console.log('clean up', d.raw, await this._store.from(d.collection).delete(d.id as string))
    }

    this.docs.length = 0
  }

  from(col: string): IStoreCollection {
    return new DStoreCollection(
      this._store.from(col),
      (doc: IDocument) => {
        if (this.isTest) {
          this.docs.push(doc)
        }
      }
    )
  }

  transaction(fn: (transaction: any) => void): Promise<any> {
    return this._store.transaction(fn)
  }

  batch(): any {
    return this._store.batch()
  }
}

export class DStoreCollection implements IStoreCollection{
  storeCollection: IStoreCollection
  registerFn: (doc: IDocument) => void

  constructor(storeCollection: IStoreCollection, registerFn: (doc: IDocument) => void) {
    this.storeCollection = storeCollection
    this.registerFn = registerFn
  }

  async create<T extends IDocument>(docT: new (raw?: any) => T): Promise<T> {
    let doc = await this.storeCollection.create(docT)

    this.registerFn(doc)

    return doc
  }

  async set(doc: IDocument): Promise<any> {
    doc.updated.push(new Interaction())

    // update ID
    doc.newId(
      `${this.storeCollection.namespace}/${this.storeCollection.collection}`,
      doc.uid as string | undefined,
    )

    let ret = await this.storeCollection.set(doc)

    this.registerFn(doc)

    return ret
  }

  async update(id: string, raw: any): Promise<any> {
    let res = await this.get(id)
    let doc = res.as(Document)[0]

    if (!doc) {
      return new Error('Document does not exist')
    }

    // update raw with proper update interaction tracking
    doc.updated.push(new Interaction())

    raw.updated = doc.raw.updated

    return this.storeCollection.update(id, raw)
  }

  get(id: string): Promise<IStoreResult> {
    return this.storeCollection.get(id)
  }

  find(params: [string, string, any][]): IStoreQuery {
    return this.storeCollection.find(params)
  }

  where(params: [string, string, any][]): IStoreQuery {
    return this.storeCollection.where(params)
  }

  delete(id: string): Promise<any> {
    return this.storeCollection.delete(id)
  }

  get namespace(): string {
    return this.storeCollection.namespace
  }

  get collection(): string {
    return this.storeCollection.collection
  }
}

